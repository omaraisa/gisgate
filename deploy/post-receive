#!/bin/bash
set -e

# Configuration
APP_DIR=/opt/apps/gisgate
BLUE_COMPOSE=$APP_DIR/docker-compose.blue.yml
GREEN_COMPOSE=$APP_DIR/docker-compose.green.yml
UPSTREAM_FILE=/etc/nginx/upstreams/gisgate_upstream.conf
ENV_FILE=$APP_DIR/.env

echo "ðŸš€ Starting GIS Gate Blue-Green Deployment..."

# Pull latest code to working directory
echo "ðŸ“¦ Pulling latest code..."
git --work-tree=$APP_DIR --git-dir=/opt/deploy/gisgate.git checkout -f main
cd $APP_DIR

# Ensure .env file exists
if [ ! -f "$ENV_FILE" ]; then
    echo "âŒ .env file not found at $ENV_FILE"
    echo "Please create .env file with required environment variables"
    exit 1
fi

# Source environment variables
set -a
source $ENV_FILE
set +a

# Detect which container is currently live
if [ -f "$UPSTREAM_FILE" ] && grep -q "8001" "$UPSTREAM_FILE"; then
    ACTIVE="blue"
    NEXT="green"
    NEXT_PORT=8002
    COMPOSE_FILE=$GREEN_COMPOSE
    ACTIVE_PORT=8001
else
    ACTIVE="green"
    NEXT="blue" 
    NEXT_PORT=8001
    COMPOSE_FILE=$BLUE_COMPOSE
    ACTIVE_PORT=8002
fi

echo "ðŸ”„ Current active: $ACTIVE (port $ACTIVE_PORT)"
echo "ðŸš€ Deploying to: $NEXT (port $NEXT_PORT)"

# Stop any existing container of the target environment
echo "ðŸ§¹ Cleaning up existing $NEXT container..."
docker stop gisgate_$NEXT 2>/dev/null || true
docker rm gisgate_$NEXT 2>/dev/null || true

# Build and start new container
echo "ðŸ”¨ Building and starting $NEXT container..."
docker compose -f $COMPOSE_FILE up -d --build

# Wait for new container to be healthy
echo "â³ Waiting for $NEXT container to be healthy..."
HEALTH_URL="http://127.0.0.1:$NEXT_PORT/api/health"
TIMEOUT=120  # 2 minutes timeout
INTERVAL=5   # Check every 5 seconds

for i in $(seq 1 $((TIMEOUT / INTERVAL))); do
    if curl -s -f "$HEALTH_URL" > /dev/null 2>&1; then
        echo "âœ… $NEXT container is healthy!"
        break
    fi
    
    if [ $i -eq $((TIMEOUT / INTERVAL)) ]; then
        echo "âŒ Timeout waiting for $NEXT container to be healthy"
        echo "ðŸ” Container logs:"
        docker logs gisgate_$NEXT --tail 20
        exit 1
    fi
    
    echo "â±ï¸  Attempt $i/$((TIMEOUT / INTERVAL)): Container not ready yet..."
    sleep $INTERVAL
done

# Verify container is actually responding with expected response
echo "ðŸ” Verifying container response..."
HEALTH_RESPONSE=$(curl -s "$HEALTH_URL" || echo "")
if echo "$HEALTH_RESPONSE" | grep -q '"status":"healthy"'; then
    echo "âœ… Health check passed!"
else
    echo "âŒ Health check failed. Response: $HEALTH_RESPONSE"
    exit 1
fi

# Create upstream directory if it doesn't exist
sudo mkdir -p /etc/nginx/upstreams

# Switch Nginx upstream
echo "ðŸ”„ Switching Nginx upstream to $NEXT (port $NEXT_PORT)..."
echo "server 127.0.0.1:$NEXT_PORT;" | sudo tee $UPSTREAM_FILE > /dev/null

# Test nginx configuration
if sudo nginx -t; then
    # Reload nginx
    sudo nginx -s reload
    echo "âœ… Nginx reloaded successfully"
else
    echo "âŒ Nginx configuration test failed"
    exit 1
fi

# Give a moment for the switch to take effect
sleep 2

# Verify the switch worked
echo "ðŸ” Verifying deployment..."
if curl -s -f "http://localhost/api/health" > /dev/null 2>&1; then
    echo "âœ… New deployment is live and responding!"
    
    # Stop and remove old container
    if [ "$ACTIVE" != "unknown" ]; then
        echo "ðŸ§¹ Stopping old $ACTIVE container..."
        docker stop gisgate_$ACTIVE 2>/dev/null || true
        docker rm gisgate_$ACTIVE 2>/dev/null || true
    fi
    
    # Clean up old images (keep last 3)
    echo "ðŸ§¹ Cleaning up old Docker images..."
    docker image prune -f
    
    echo ""
    echo "ðŸŽ‰ Deployment completed successfully!"
    echo "ðŸƒ Now running: $NEXT environment on port $NEXT_PORT"
    echo "ðŸ“Š Application health: $(curl -s http://localhost/api/health | jq -r .status 2>/dev/null || echo 'Unknown')"
    
else
    echo "âŒ Deployment verification failed"
    echo "ðŸ”„ Rolling back to previous version..."
    echo "server 127.0.0.1:$ACTIVE_PORT;" | sudo tee $UPSTREAM_FILE > /dev/null
    sudo nginx -s reload
    exit 1
fi